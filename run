#!/usr/bin/env bash
set -euo pipefail

COMMAND="${1:-help}"
SUBCOMMAND="${2:-}"
MODE="${3:-}"
CONFIG_FILE=".harbormaster/.meta/project.json"

err() { echo "Error: $*" >&2; exit 1; }

# Normalize args: commands without subcommands treat $2 as mode if $3 not provided.
if [[ "$COMMAND" != "cleanup" && -n "$SUBCOMMAND" && -z "$MODE" ]]; then
  MODE="$SUBCOMMAND"
  SUBCOMMAND=""
fi

resolve_config_path() {
  local primary="$CONFIG_FILE"
  local legacy_meta=".harbormaster/project.json"
  local legacy=".project.json"
  if [[ -f "$primary" ]]; then
    echo "$primary"
    return
  fi
  if [[ -f "$legacy_meta" ]]; then
    echo "$legacy_meta"
    return
  fi
  if [[ -f "$legacy" ]]; then
    echo "$legacy"
    return
  fi
  err "Could not find project config at $primary (or $legacy_meta, $legacy)."
}

resolve_mode() {
  local default_mode="$1"
  local mode
  if [[ -n "${MODE:-}" ]]; then
    mode="$MODE"
  elif [[ -n "$default_mode" ]]; then
    mode="$default_mode"
  else
    err "Mode required. Use dev or prod."
  fi

  if [[ "$mode" != "dev" && "$mode" != "prod" ]]; then
    err "Unknown mode '$mode'. Use dev or prod."
  fi

  echo "$mode"
}

get_project_version() {
  local config_path
  config_path="$(resolve_config_path)"
  CONFIG_FILE="$config_path" node <<'NODE'
const fs = require('fs');
const path = process.env.CONFIG_FILE;

function coerceInt(value, fallback) {
  if (Number.isInteger(value) && value >= 0) return value;
  if (typeof value === 'string' && /^[0-9]+$/.test(value)) return Number.parseInt(value, 10);
  return fallback;
}

function coerceString(value) {
  if (typeof value !== 'string') return '';
  return value.trim();
}

function deriveVersion(cfg) {
  const major = coerceInt(cfg.version_major, 0);
  const minor = coerceInt(cfg.version_minor, 0);
  const prerelease = coerceString(cfg.version_prerelease);
  const explicit = coerceString(cfg.project_version);
  const patch = new Date().getFullYear() % 100;
  if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-[0-9A-Za-z-.]+)?(?:\+[0-9A-Za-z-.]+)?$/.test(explicit)) {
    return explicit;
  }
  const base = `${major}.${minor}.${patch}`;
  return prerelease ? `${base}-${prerelease}` : base;
}

try {
  const raw = fs.readFileSync(path, 'utf8');
  const cfg = JSON.parse(raw);
  const version = deriveVersion(cfg);
  if (!/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-[0-9A-Za-z-.]+)?(?:\+[0-9A-Za-z-.]+)?$/.test(version)) {
    process.exit(1);
  }
  console.log(version);
} catch (error) {
  process.exit(1);
}
NODE
}

bump_project_minor() {
  local config_path
  config_path="$(resolve_config_path)"
  CONFIG_FILE="$config_path" node <<'NODE'
const fs = require('fs');
const path = process.env.CONFIG_FILE;

function coerceInt(value, fallback) {
  if (Number.isInteger(value) && value >= 0) return value;
  if (typeof value === 'string' && /^[0-9]+$/.test(value)) return Number.parseInt(value, 10);
  return fallback;
}

function coerceString(value) {
  if (typeof value !== 'string') return '';
  return value.trim();
}

function deriveVersion(cfg) {
  const major = coerceInt(cfg.version_major, 0);
  const minor = coerceInt(cfg.version_minor, 0);
  const prerelease = coerceString(cfg.version_prerelease);
  const explicit = coerceString(cfg.project_version);
  const patch = new Date().getFullYear() % 100;
  if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-[0-9A-Za-z-.]+)?(?:\+[0-9A-Za-z-.]+)?$/.test(explicit)) {
    return explicit;
  }
  const base = `${major}.${minor}.${patch}`;
  return prerelease ? `${base}-${prerelease}` : base;
}

try {
  const raw = fs.readFileSync(path, 'utf8');
  const cfg = JSON.parse(raw);
  cfg.version_minor = coerceInt(cfg.version_minor, 0) + 1;
  const nextVersion = deriveVersion(cfg);
  fs.writeFileSync(path, JSON.stringify(cfg, null, 2) + '\n');
  console.log(`Bumped version_minor to ${cfg.version_minor} (next version ${nextVersion})`);
} catch (error) {
  console.error('Failed to bump version_minor:', error.message || error);
  process.exit(1);
}
NODE
}

bump_project_major() {
  local config_path
  config_path="$(resolve_config_path)"
  CONFIG_FILE="$config_path" node <<'NODE'
const fs = require('fs');
const path = process.env.CONFIG_FILE;

function coerceInt(value, fallback) {
  if (Number.isInteger(value) && value >= 0) return value;
  if (typeof value === 'string' && /^[0-9]+$/.test(value)) return Number.parseInt(value, 10);
  return fallback;
}

function coerceString(value) {
  if (typeof value !== 'string') return '';
  return value.trim();
}

function deriveVersion(cfg) {
  const major = coerceInt(cfg.version_major, 0);
  const minor = coerceInt(cfg.version_minor, 0);
  const prerelease = coerceString(cfg.version_prerelease);
  const explicit = coerceString(cfg.project_version);
  const patch = new Date().getFullYear() % 100;
  if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-[0-9A-Za-z-.]+)?(?:\+[0-9A-Za-z-.]+)?$/.test(explicit)) {
    return explicit;
  }
  const base = `${major}.${minor}.${patch}`;
  return prerelease ? `${base}-${prerelease}` : base;
}

try {
  const raw = fs.readFileSync(path, 'utf8');
  const cfg = JSON.parse(raw);
  cfg.version_major = coerceInt(cfg.version_major, 0) + 1;
  cfg.version_minor = 0;
  const nextVersion = deriveVersion(cfg);
  fs.writeFileSync(path, JSON.stringify(cfg, null, 2) + '\n');
  console.log(`Bumped version_major to ${cfg.version_major}, reset version_minor to 0 (next version ${nextVersion})`);
} catch (error) {
  console.error('Failed to bump version_major:', error.message || error);
  process.exit(1);
}
NODE
}

sync_package_version() {
  local version
  version="$(get_project_version)" || err "Could not derive project version"
  VERSION="$version" node <<'NODE'
const fs = require('fs');
const pkgPath = 'package.json';
const version = process.env.VERSION;
const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
if (pkg.version !== version) {
  pkg.version = version;
  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
  console.log(`Updated package.json version to ${version}`);
} else {
  console.log(`package.json version already ${version}`);
}
console.log(`Using extension name: ${pkg.name}`);
NODE
}

cleanup_builds() {
  local builds_dir="builds"
  if [[ ! -d "$builds_dir" ]]; then
    echo "No builds directory found."
    return
  fi

  shopt -s nullglob
  local files=("$builds_dir"/*)
  shopt -u nullglob
  if [[ ${#files[@]} -eq 0 ]]; then
    echo "No build artifacts to move."
    return
  fi

  local today
  today="$(date +%Y-%m-%d)"
  local root_dir="${builds_dir}/Harbormaster_Builds_${today}"
  mkdir -p "$root_dir"

  for src in "${files[@]}"; do
    if [[ -d "$src" ]]; then
      continue
    fi
    local filename
    filename="$(basename "$src")"
    local mode_subdir="unknown"
    if [[ "$filename" =~ -dev\.vsix$ ]]; then
      mode_subdir="dev"
    elif [[ "$filename" =~ -prod\.vsix$ ]]; then
      mode_subdir="prod"
    fi
    local dest_dir="${root_dir}/${mode_subdir}"
    mkdir -p "$dest_dir"
    local dest="${dest_dir}/${filename}"
    if [[ -f "$dest" ]]; then
      echo "File exists: ${dest}"
      read -r -p "Overwrite (o/O), keep both (default), or cancel (c/C)? " choice
      case "$choice" in
        o|O)
          rm -f "$dest"
          ;;
        c|C)
          echo "Canceled."
          return
          ;;
        *)
          local idx=1 alt
          while :; do
            alt="${dest_dir}/${filename%.*}-${idx}.${filename##*.}"
            [[ -f "$alt" ]] || { dest="$alt"; break; }
            idx=$((idx+1))
          done
          ;;
      esac
    fi
    mv "$src" "$dest"
    echo "Moved $(basename "$src") -> $dest_dir/"
  done
}

cmd_compile() {
  local mode
  mode="$(resolve_mode "dev")"
  sync_package_version
  local version
  version="$(get_project_version)" || err "Could not derive project version"
  echo "Compiling Harbormaster ${version} (mode: ${mode})"
  HARBORMASTER_DEV_TOOLS=$([[ "$mode" == "dev" ]] && echo "1" || echo "0") npm run compile
}

cmd_watch() {
  local mode
  mode="$(resolve_mode "dev")"
  sync_package_version
  local version
  version="$(get_project_version)" || err "Could not derive project version"
  echo "Starting watch for Harbormaster ${version} (mode: ${mode})"
  HARBORMASTER_DEV_TOOLS=$([[ "$mode" == "dev" ]] && echo "1" || echo "0") npm run watch
}

cmd_build() {
  local mode
  mode="$(resolve_mode "")"
  if [[ "$mode" == "prod" ]]; then
    bump_project_minor
  else
    echo "Skipping version bump in dev mode."
  fi
  sync_package_version
  local version pkgName target choice
  version="$(get_project_version)" || err "project_version not found"
  echo "Building Harbormaster ${version} (mode: ${mode})"
  HARBORMASTER_DEV_TOOLS=$([[ "$mode" == "dev" ]] && echo "1" || echo "0") npm run compile

  mkdir -p builds
  pkgName="$(node -p "require('./package.json').name")"
  target="builds/${pkgName}-${version}-${mode}.vsix"

  if [[ -f "$target" ]]; then
    echo "VSIX already exists: $target"
    if [[ "$mode" == "dev" ]]; then
      read -r -p "Overwrite (default), Keep both (k/K), or cancel (c/C/other)? " choice
      case "$choice" in
        ""|o|O)
          rm -f "$target"
          ;;
        k|K)
          local idx=1 alt
          while :; do
            alt="builds/${pkgName}-${version}-${mode}-${idx}.vsix"
            [[ -f "$alt" ]] || { target="$alt"; break; }
            idx=$((idx+1))
          done
          ;;
        *)
          echo "Canceled."
          exit 1
          ;;
      esac
    else
      read -r -p "Cancel (default), overwrite (o/O), or keep both (k/K)? " choice
      case "$choice" in
        o|O)
          rm -f "$target"
          ;;
        k|K)
          local idx=1 alt
          while :; do
            alt="builds/${pkgName}-${version}-${mode}-${idx}.vsix"
            [[ -f "$alt" ]] || { target="$alt"; break; }
            idx=$((idx+1))
          done
          ;;
        *)
          echo "Canceled."
          exit 1
          ;;
      esac
    fi
  fi

  npx vsce package -o "$target"
}

case "$COMMAND" in
  compile)
    cmd_compile
    ;;
  watch)
    cmd_watch
    ;;
  build)
    cmd_build
    ;;
  cleanup)
    case "$SUBCOMMAND" in
      builds)
        cleanup_builds
        ;;
      ""|-h|--help|help)
        cat <<'EOF'
Usage: ./run cleanup <subcommand>

Subcommands:
  builds   Move all files in ./builds into ./builds/Harbormaster_Builds_<YYYY-MM-DD>/, prompting on conflicts (default keep both).
EOF
        ;;
      *)
        err "Unknown cleanup subcommand: $SUBCOMMAND"
        ;;
    esac
    ;;
  major_update)
    bump_project_major
    ;;
  -h|--help|help)
    cat <<'EOF'
Usage: ./run <command>

Commands:
  compile [dev|prod]   Derive version from .project.json and run a single TypeScript build (no VSIX). Defaults to dev mode.
  watch [dev|prod]     Derive version and run tsc in watch mode. Defaults to dev mode.
  build <dev|prod>     Derive version, build, and package into ./builds/*.vsix (prompts on conflicts). Requires explicit mode. Prod auto-bumps version_minor; dev skips bump. Filename includes mode.
  cleanup <subcmd>     Run cleanup helpers (e.g., `cleanup builds` to archive build artifacts).
  major_update         Bump version_major and reset version_minor to 0 (writes .project.json)
  help      Show this help
EOF
    ;;
  *)
    echo "Unknown command: $COMMAND"
    echo "Use ./run help to list commands."
    ;;
esac
